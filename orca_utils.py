# orca_utils.py
import os
import re
import shutil
import tempfile
import subprocess
from pathlib import Path
# 依存関係: logging_utilsからロガーを取得
from logging_utils import get_logger

# プロット機能の条件付きインポート（元のコードの振る舞いを維持）
try:
    import matplotlib.pyplot as plt
    PLOTTING_AVAILABLE = True
except ImportError:
    PLOTTING_AVAILABLE = False
    
_orca_utils_logger = get_logger('orca_utils')

# ★★★ ここからが変更点 ★★★
# 致命的（リトライ不要）なエラーパターンを定義
FATAL_ERROR_PATTERNS = [
    re.compile(r"Basis set.+not found", re.IGNORECASE),
    re.compile(r"Unknown keyword", re.IGNORECASE),
    re.compile(r"FATAL ERROR", re.IGNORECASE),
    re.compile(r"ABORTING THE RUN", re.IGNORECASE),
    re.compile(r"Could not find.+basis", re.IGNORECASE),
    re.compile(r"Error in input line", re.IGNORECASE),
]
# ★★★ 変更点ここまで ★★★

# --- ORCA INPUT GENERATION ---

def generate_orca_input(config, mol_name, atoms, coords, calc_type='opt'):
    """Generates the content for an ORCA input file."""
    # ... (元のコードのロジックを再現)
    calc_settings = config['orca']['settings_opt'] if calc_type == 'opt' else config['orca']['settings_freq']
    
    input_content = f"""# ORCA Input generated by pipeline
# Molecule: {mol_name} | Type: {calc_type}

! {calc_settings}

%pal nprocs {config['orca']['num_cores']} end

* xyz {config['orca']['charge']} {config['orca']['multiplicity']}
"""
    for atom, coord in zip(atoms, coords):
        input_content += f"  {atom} {coord[0]:.6f} {coord[1]:.6f} {coord[2]:.6f}\n"
        
    input_content += "*\n"
    
    return input_content


def parse_xyz(xyz_content):
    """Parses XYZ file content into atom list and coordinate list."""
    # ... (元のコードのロジックを再現)
    lines = xyz_content.strip().split('\n')
    if len(lines) < 3:
        _orca_utils_logger.error("XYZ file is too short.")
        return [], []

    atoms = []
    coords = []
    for line in lines[2:]:
        parts = line.split()
        if len(parts) >= 4:
            try:
                atom = parts[0]
                coord = [float(parts[1]), float(parts[2]), float(parts[3])]
                atoms.append(atom)
                coords.append(coord)
            except ValueError:
                continue
    
    return atoms, coords

# --- ORCA OUTPUT UTILITIES ---

def check_orca_output(output_path):
    """
    Checks ORCA output file for success/failure and classifies error type.
    Returns: (success (bool), message (str), error_type ('RECOVERABLE' or 'FATAL'))
    (仕様書に基づく変更)
    """
    # ... (元のコードのロジックを再現)
    output_path = Path(output_path)
    if not output_path.exists():
        # ★★★ 変更点 ★★★
        return False, "Output file not found.", "FATAL"
    
    with open(output_path, 'r', errors='ignore') as f:
        content = f.read()

    # 1. 成功のチェック
    if re.search(r"ORCA TERMINATED NORMALLY", content, re.IGNORECASE):
        if 'opt' in output_path.stem:
            if re.search(r"THE OPTIMIZATION HAS CONVERGED", content):
                # ★★★ 変更点 ★★★
                return True, "Optimization successful.", "N/A"
            else:
                # ★★★ 変更点 ★★★
                # 収束失敗はリトライ可能
                return False, "Optimization failed to converge.", "RECOVERABLE"
        # ★★★ 変更点 ★★★
        return True, "Job successful (terminated normally).", "N/A"

    # 2. 失敗のチェック (致命的エラー)
    # ★★★ ここからが変更点 ★★★
    for pattern in FATAL_ERROR_PATTERNS:
        match = pattern.search(content)
        if match:
            message = match.group(0).strip()
            return False, f"Fatal Error: {message}", "FATAL"
    # ★★★ 変更点ここまで ★★★

    # 3. その他の失敗 (リトライ可能とみなす)
    # (例: SCF未収束だが、FATALやABORTINGではない場合)
    if re.search(r"SCF NOT CONVERGED", content, re.IGNORECASE):
        return False, "SCF failed to converge.", "RECOVERABLE"

    # ★★★ 変更点 ★★★
    return False, "ORCA job did not terminate normally.", "RECOVERABLE"


def extract_final_structure(output_path):
    """Extracts the final optimized geometry from an ORCA output file."""
    # ... (元のコードのロジックを再現)
    output_path = Path(output_path)
    if not output_path.exists():
        return None, None
    
    with open(output_path, 'r', errors='ignore') as f:
        content = f.read()

    match = re.search(
        r"FINAL COORDINATES \(CARTESIAN\)\n-+\n[^\n]*\n-+\n(.*?)--------------------", 
        content, re.DOTALL
    )
    
    if match:
        coords_block = match.group(1).strip()
        atoms = []
        coords = []
        for line in coords_block.split('\n'):
            parts = line.split()
            if len(parts) >= 4:
                try:
                    atom = parts[0] 
                    coord = [float(parts[1]), float(parts[2]), float(parts[3])]
                    atoms.append(atom)
                    coords.append(coord)
                except ValueError:
                    continue
        return atoms, coords

    _orca_utils_logger.warning(f"Could not find final coordinates in {output_path.name}.")
    return None, None

# --- PLOTTING UTILITIES ---

def _get_energy_data(output_path):
    # ... (元のコードのロジックを再現)
    path = Path(output_path)
    if not path.exists():
        return []
    with open(path, 'r', errors='ignore') as f:
        content = f.read()
    
    energies = re.findall(r"E_(\d+)\s*=\s*([-\d\.]+)", content)
    return [float(e[1]) for e in energies]


def generate_energy_plot(output_path, save_dir):
    """Generates and saves a simple energy plot."""
    if not PLOTTING_AVAILABLE:
        _orca_utils_logger.warning("matplotlib not available. Cannot generate energy plot.")
        return False
    # ... (元のコードのロジックを再現)
    try:
        data = _get_energy_data(output_path)
        if not data:
            _orca_utils_logger.info("No energy data found for plotting.")
            return False

        save_path = Path(save_dir) / f"{Path(output_path).stem}_energy.png"
        
        plt.figure()
        plt.plot(data)
        plt.title(f"Energy Convergence: {Path(output_path).stem}")
        plt.xlabel("Step")
        plt.ylabel("Energy (a.u.)")
        plt.savefig(save_path)
        plt.close()
        _orca_utils_logger.info(f"Saved energy plot to {save_path.name}")
        return True

    except Exception as e:
        _orca_utils_logger.error(f"Error generating energy plot: {e}")
        return False


def generate_comparison_plot(opt_path, freq_path, save_dir):
    """Generates and saves a comparison plot for optimization and frequency energies."""
    if not PLOTTING_AVAILABLE:
        _orca_utils_logger.warning("matplotlib not available. Cannot generate comparison plot.")
        return False
    # ... (元のコードのロジックを再現)
    try:
        opt_data = _get_energy_data(opt_path)
        freq_data = _get_energy_data(freq_path)
        
        if not opt_data or not freq_data:
            _orca_utils_logger.info("Missing data for comparison plot.")
            return False

        save_path = Path(save_dir) / f"{Path(opt_path).stem}_comparison.png"
        
        plt.figure()
        plt.bar(['Optimization (Final)', 'Frequency (Final)'], [opt_data[-1], freq_data[-1]])
        plt.title(f"Final Energy Comparison: {Path(opt_path).stem}")
        plt.ylabel("Energy (a.u.)")
        plt.savefig(save_path)
        plt.close()
        _orca_utils_logger.info(f"Saved comparison plot to {save_path.name}")
        return True

    except Exception as e:
        _orca_utils_logger.error(f"Error generating comparison plot: {e}")
        return False
