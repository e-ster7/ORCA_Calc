# orca_utils.py
import os
import re
import shutil
import tempfile
import subprocess
from pathlib import Path
# 依存関係: logging_utilsからロガーを取得
from logging_utils import get_logger

# プロット機能の条件付きインポート（元のコードの振る舞いを維持）
try:
    import matplotlib.pyplot as plt
    PLOTTING_AVAILABLE = True
except ImportError:
    PLOTTING_AVAILABLE = False
    
_orca_utils_logger = get_logger('orca_utils')

# 致命的（リトライ不要）なエラーパターンを定義
FATAL_INPUT_ERROR_PATTERNS = [
    re.compile(r"Basis set.+not found", re.IGNORECASE),
    re.compile(r"Unknown keyword", re.IGNORECASE),
    re.compile(r"FATAL ERROR", re.IGNORECASE),
    re.compile(r"ABORTING THE RUN", re.IGNORECASE),
    re.compile(r"Could not find.+basis", re.IGNORECASE),
    re.compile(r"Error in input line", re.IGNORECASE),
]

# リソース不足（リトライ不要）なエラーパターンを定義
FATAL_RESOURCE_ERROR_PATTERNS = [
    re.compile(r"Out of Memory", re.IGNORECASE),
    re.compile(r"Allocation failed", re.IGNORECASE),
    re.compile(r"No space left on device", re.IGNORECASE),
    re.compile(r"Disk quota exceeded", re.IGNORECASE),
]

# --- ORCA INPUT GENERATION ---

def generate_orca_input(config, mol_name, atoms, coords, calc_type='opt'):
    """Generates the content for an ORCA input file."""
    
    num_cores = config['orca']['nprocs']
    
    method = config['orca'].get('method', 'B3LYP')
    basis = config['orca'].get('basis', 'def2-SVP')
    
    if calc_type == 'opt':
        calc_type_keyword = 'OPT'
    elif calc_type == 'freq':
        calc_type_keyword = 'FREQ'
    else:
        calc_type_keyword = ''
    
    calc_keywords = f"{calc_type_keyword} {method} {basis} TightSCF"
    
    optional_keywords = []
    
    use_rijcosx = config['orca'].getboolean('use_rijcosx', fallback=False)
    if use_rijcosx:
        optional_keywords.append('RIJCOSX')
    
    solvent = config['orca'].get('solvent', '').strip()
    if solvent:
        solvent_model = config['orca'].get('solvent_model', 'CPCM')
        optional_keywords.append(f'{solvent_model}({solvent})')
    
    if optional_keywords:
        calc_keywords += " " + " ".join(optional_keywords)
    
    # 入力ファイルの生成
    input_content = f"""# ORCA Input generated by pipeline
# Molecule: {mol_name} | Type: {calc_type}

! {calc_keywords}

%pal nprocs {num_cores} end
%maxcore {config['orca'].get('maxcore', '2000')}

* xyz {config['orca']['charge']} {config['orca']['multiplicity']}
"""
    for atom, coord in zip(atoms, coords):
        input_content += f"  {atom} {coord[0]:.6f} {coord[1]:.6f} {coord[2]:.6f}\n"
        
    input_content += "*\n"
    
    return input_content


def parse_xyz(xyz_content):
    """Parses XYZ file content into atom list and coordinate list."""
    lines = xyz_content.strip().split('\n')
    if len(lines) < 3:
        _orca_utils_logger.error("XYZ file is too short.")
        return [], []

    atoms = []
    coords = []
    for line in lines[2:]:
        parts = line.split()
        if len(parts) >= 4:
            try:
                atom = parts[0]
                coord = [float(parts[1]), float(parts[2]), float(parts[3])]
                atoms.append(atom)
                coords.append(coord)
            except ValueError:
                continue
    
    return atoms, coords

# --- ORCA OUTPUT UTILITIES ---

def check_orca_output(output_path):
    """
    Checks ORCA output file for success/failure and classifies error type.
    Returns: (success (bool), message (str), error_type ('RECOVERABLE', 'FATAL_INPUT', 'FATAL_RESOURCE'))
    """
    output_path = Path(output_path)
    if not output_path.exists():
        return False, "Output file not found.", "FATAL_INPUT"
    
    with open(output_path, 'r', errors='ignore') as f:
        content = f.read()

    # 1. 成功のチェック
    if re.search(r"ORCA TERMINATED NORMALLY", content, re.IGNORECASE):
        if 'opt' in output_path.stem:
            if re.search(r"THE OPTIMIZATION HAS CONVERGED", content):
                return True, "Optimization successful.", "N/A"
            else:
                return False, "Optimization failed to converge.", "RECOVERABLE"
        return True, "Job successful (terminated normally).", "N/A"

    # 2. 失敗のチェック (致命的エラー: リソース)
    for pattern in FATAL_RESOURCE_ERROR_PATTERNS:
        match = pattern.search(content)
        if match:
            message = match.group(0).strip()
            return False, f"Fatal Resource Error: {message}", "FATAL_RESOURCE"

    # 3. 失敗のチェック (致命的エラー: 入力ミス)
    for pattern in FATAL_INPUT_ERROR_PATTERNS:
        match = pattern.search(content)
        if match:
            message = match.group(0).strip()
            return False, f"Fatal Input Error: {message}", "FATAL_INPUT"

    # 4. その他の失敗 (リトライ可能とみなす)
    if re.search(r"SCF NOT CONVERGED", content, re.IGNORECASE):
        return False, "SCF failed to converge.", "RECOVERABLE"

    return False, "ORCA job did not terminate normally.", "RECOVERABLE"


def extract_final_structure(output_path):
    """
    Extracts the final optimized geometry from an ORCA output file.
    
    Handles both successful optimization (CARTESIAN COORDINATES (ANGSTROEM))
    and failed optimization (FINAL COORDINATES (CARTESIAN)) cases.
    
    Returns:
        tuple: (atoms, coords) where atoms is a list of element symbols
               and coords is a list of [x, y, z] coordinates, or (None, None) if not found
    """
    output_path = Path(output_path)
    if not output_path.exists():
        _orca_utils_logger.warning(f"Output file not found: {output_path}")
        return None, None
    
    with open(output_path, 'r', errors='ignore') as f:
        content = f.read()

    # パターン1: 成功時の座標ブロック (CARTESIAN COORDINATES (ANGSTROEM))
    success_pattern = re.compile(
        r"CARTESIAN COORDINATES \(ANGSTROEM\)\s*\n-+\n(.*?)\n-{10,}",
        re.DOTALL
    )
    
    match = success_pattern.search(content)
    
    if match:
        _orca_utils_logger.debug(f"Found successful optimization coordinates in {output_path.name}")
        coords_block = match.group(1).strip()
        return _parse_coordinate_block(coords_block, format_type='success')
    
    # パターン2: 失敗時の座標ブロック (FINAL COORDINATES (CARTESIAN))
    failure_pattern = re.compile(
        r"FINAL COORDINATES \(CARTESIAN\)\n-+\n[^\n]*\n-+\n(.*?)\n-{10,}",
        re.DOTALL
    )
    
    match = failure_pattern.search(content)
    
    if match:
        _orca_utils_logger.debug(f"Found final (non-converged) coordinates in {output_path.name}")
        coords_block = match.group(1).strip()
        return _parse_coordinate_block(coords_block, format_type='failure')
    
    # どちらのパターンも見つからなかった場合
    _orca_utils_logger.warning(f"Could not find coordinate block in {output_path.name}")
    return None, None


def _parse_coordinate_block(coords_block, format_type='success'):
    """
    Helper function to parse coordinate blocks from ORCA output.
    
    Args:
        coords_block: The text block containing coordinates
        format_type: 'success' for ANGSTROEM format, 'failure' for CARTESIAN format
    
    Returns:
        tuple: (atoms, coords) lists
    """
    atoms = []
    coords = []
    
    for line in coords_block.split('\n'):
        parts = line.split()
        
        # 成功時のフォーマット: Element X Y Z
        if format_type == 'success' and len(parts) >= 4:
            try:
                atom = parts[0]
                coord = [float(parts[1]), float(parts[2]), float(parts[3])]
                atoms.append(atom)
                coords.append(coord)
            except (ValueError, IndexError):
                continue
        
        # ★★★ ここからが修正点 ★★★
        # 失敗時のフォーマット: (Index) Element X Y Z
        elif format_type == 'failure' and len(parts) >= 4: # 実際には 5 >= 4
            try:
                # 失敗時は Index(0) Element(1) X(2) Y(3) Z(4) の形式
                # ...ですが、ORCA 5.0.4では Index Element X Y Z のようです。
                # 確実性を高めるため、最後の3つを座標とし、その前を元素記号とします。
                
                atom = parts[-4] # 元素記号
                x = float(parts[-3]) # X座標
                y = float(parts[-2]) # Y座標
                z = float(parts[-1]) # Z座標
                
                coord = [x, y, z]
                atoms.append(atom)
                coords.append(coord)
                
            except (ValueError, IndexError):
                # ヘッダー行などをスキップ
                continue
        # ★★★ 修正点ここまで ★★★
    
    if not atoms:
        _orca_utils_logger.warning("No valid coordinates found in block")
        return None, None
    
    return atoms, coords


# --- PLOTTING UTILITIES ---

def _get_energy_data(output_path):
    path = Path(output_path)
    if not path.exists():
        return []
    with open(path, 'r', errors='ignore') as f:
        content = f.read()
    
    energies = re.findall(r"E_(\d+)\s*=\s*([-\d\.]+)", content)
    return [float(e[1]) for e in energies]


def generate_energy_plot(output_path, save_dir):
    """Generates and saves a simple energy plot."""
    if not PLOTTING_AVAILABLE:
        _orca_utils_logger.warning("matplotlib not available. Cannot generate energy plot.")
        return False
    
    try:
        data = _get_energy_data(output_path)
        if not data:
            _orca_utils_logger.info("No energy data found for plotting.")
            return False

        save_path = Path(save_dir) / f"{Path(output_path).stem}_energy.png"
        
        plt.figure()
        plt.plot(data)
        plt.title(f"Energy Convergence: {Path(output_path).stem}")
        plt.xlabel("Step")
        plt.ylabel("Energy (a.u.)")
        plt.savefig(save_path)
        plt.close()
        _orca_utils_logger.info(f"Saved energy plot to {save_path.name}")
        return True

    except Exception as e:
        _orca_utils_logger.error(f"Error generating energy plot: {e}")
        return False


def generate_comparison_plot(opt_path, freq_path, save_dir):
    """Generates and saves a comparison plot for optimization and frequency energies."""
    if not PLOTTING_AVAILABLE:
        _orca_utils_logger.warning("matplotlib not available. Cannot generate comparison plot.")
        return False
    
    try:
        opt_data = _get_energy_data(opt_path)
        freq_data = _get_energy_data(freq_path)
        
        if not opt_data or not freq_data:
            _orca_utils_logger.info("Missing data for comparison plot.")
            return False

        save_path = Path(save_dir) / f"{Path(opt_path).stem}_comparison.png"
        
        plt.figure()
        plt.bar(['Optimization (Final)', 'Frequency (Final)'], [opt_data[-1], freq_data[-1]])
        plt.title(f"Final Energy Comparison: {Path(opt_path).stem}")
        plt.ylabel("Energy (a.u.)")
        plt.savefig(save_path)
        plt.close()
        _orca_utils_logger.info(f"Saved comparison plot to {save_path.name}")
        return True

    except Exception as e:
        _orca_utils_logger.error(f"Error generating comparison plot: {e}")
        return False
